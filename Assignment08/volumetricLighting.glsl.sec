// TODO If you want to change from central to intermediate differences, do it here by commenting/uncommenting
// the corresponding define
#define USE_CENTRAL
//#define USE_INTERMEDIATE

// first three coordinates: position
// w-component: radius
const vec4 sphere1 = vec4(0, 0, 0, 1);
const vec4 sphere2 = vec4(1, 1, 1, 1.5);
const vec4 sphere3 = vec4(1, 0, 3, 0.5);

// density of objects
const float s1Dens = 0.015;
const float s2Dens = 0.02;
const float s3Dens = 0.03;

// bounding box
const vec3 bbMin = vec3(-1.0, -1.0, -1.0);
const vec3 bbMax = vec3(2.5, 2.5, 3.5);
const vec3 bbSize = bbMax - bbMin;

// additional camera parameters
const float fovy = 45.0;
const float zNear = 0.1;

// light direction
const vec3 lightDir = vec3(1.0, -1.0, -1.0);

const vec4 lightColor = vec4(1);
const vec4 specularColor = vec4(1);
const float ka = 0.5;  // ambient contribution
const float kd = 0.5;  // diffuse contribution
const float ks = 0.7;  // specular contribution
const float exponent = 50.0;  // specular exponent (shininess)

// number of maximum raycasting samples per ray
const int sampleNum = 256;

// width of one voxel in volume space
const float voxelWidth = 1.0 / 64.0;

// epsilon for comparisons
const float EPS = 0.000001;

/**
 *	Returns whether a given point is inside a given sphere.
 *  
 * 	@param point The point that is tested against the sphere.
 * 	@param sphere The sphere parameters. xyz = position, w = radius
 *	@return True, when the point is inside the sphere, false otherwise
 */
bool isInSphere(vec3 point, vec4 sphere)
{
    vec3 spherePos = sphere.xyz;
    
    if(length(point - spherePos) <= sphere.w)
        return true;
    else
        return false;
}

/**
 *	Returns whether a given point is inside a given cube.
 *  
 * 	@param point The point that is tested against the cube.
 * 	@param cube The cube parameters. xyz = position, w = half of the cube width
 *	@return True, when the point is inside the cube, false otherwise
 */
bool isInCube(vec3 point, vec4 cube)
{
	vec3 dist = abs(point.xyz - cube.xyz);
    
    if(all(lessThan(dist, vec3(cube.w))))
        return true;
    else return false;
}

/**
 *	Samples the volume texture at a given position.
 *
 *	@param volumeCoord The position one wants to retrieve the sample of (in world coordinates).
 *	@return The sample value at the given position.
 */
float sampleVolume(vec3 volumeCoord)
{
    bool in1 = isInCube(volumeCoord, sphere1);
    bool in2 = isInCube(volumeCoord, sphere2);
    bool in3 = isInSphere(volumeCoord, sphere3);
    
    float result = 0.0;
    
    if(in1)
    	result += s1Dens;
    
    if(in2)
        result += s2Dens;
    
    if(in3)
        result += s3Dens;
    
    return result;
}

/**
 *	Evaluates the transfer function for a given sample value
 * 	
 *	@param value The sample value
 *	@return The color for the given sample value
 */
vec4 transferFunction(float value)
{
    if(value > EPS)
    {
    	if(value > s1Dens + EPS)
        {
        	if(value > s2Dens + EPS)
            {   
            	if(value > s1Dens + s2Dens + EPS)
                {
                	return vec4(0, 0, 0, 1.0);
                }
                return vec4(1, 0, 0, 1.0);
            }
            return vec4(0, 1, 0, 1.0);
        }
        return vec4(0, 0, 1, 1.0);
    }
    return vec4(0);
}

/**
 *	Intersects a ray with the bounding box and returs the intersection points
 * 	
 * 	@param rayOrig The origin of the ray
 * 	@param rayDir The direction of the ray
 *  @param tNear OUT: The distance from the ray origin to the first intersection point
 *	@param tFar OUT: The distance from the ray origin to the second intersection point
 *	@return True if the ray intersects the bounding box, false otherwise.
 */
bool intersectBoundingBox(vec3 rayOrig, vec3 rayDir, out float tNear, out float tFar)
{
	vec3 invR = vec3(1.0) / rayDir;
    vec3 tbot = invR * (bbMin - rayOrig);
    vec3 ttop = invR * (bbMax - rayOrig);
    
    vec3 tmin = min(ttop, tbot);
    vec3 tmax = max(ttop, tbot);
    
    tNear = max(max(tmin.x, tmin.y), max(tmin.x, tmin.z));
    tFar = min(min(tmax.x, tmax.y), min(tmax.x, tmax.z));
        
    return (tNear < tFar);
}

/**
 *	Returns the gradient at a given position using central differences
 *	@param pos The postion from which the gradient should be determined
 *	@return The gradient at pos.
 */
vec3 gradientCentral(vec3 pos)
{
    vec3 result;
	//TODO: Insert codes here
    float xPlus = (pos.x == bbMax.x) ? bbMax.x : pos.x + bbSize.x / float(sampleNum);
    float xMinus = (pos.x == bbMin.x) ? bbMin.x : pos.x - bbSize.x / float(sampleNum);
    float yPlus = (pos.y == bbMax.y) ? bbMax.y : pos.y + bbSize.y / float(sampleNum);
    float yMinus = (pos.y == bbMin.y) ? bbMin.y : pos.y - bbSize.y / float(sampleNum);
    float zPlus = (pos.z == bbMax.z) ? bbMax.z : pos.z + bbSize.z / float(sampleNum);
    float zMinus = (pos.z == bbMin.z) ? bbMin.z : pos.z - bbSize.z / float(sampleNum);
    vec3 posXplus = vec3(xPlus, pos.y, pos.z);
    vec3 posXminus = vec3(xMinus, pos.y, pos.z);
    vec3 posYplus = vec3(pos.x, yPlus, pos.z);
    vec3 posYminus = vec3(pos.x, yMinus, pos.z);
    vec3 posZplus = vec3(pos.x, pos.y, zPlus);
    vec3 posZminus = vec3(pos.x, pos.y, zMinus);
    float gradientX = sampleVolume(posXplus) - sampleVolume(posXminus);
    float gradientY = sampleVolume(posYplus) - sampleVolume(posYminus);
    float gradientZ = sampleVolume(posZplus) - sampleVolume(posZminus);
    result = normalize(vec3(gradientX, gradientY, gradientZ));
    return result;
}

/**
 *	Returns the gradient at a given position using intermediate differences
 *
 *	@param pos The postion from which the gradient should be determined
 *	@return The gradient at pos.
 */
vec3 gradientIntermediate(vec3 pos)
{
    vec3 result;
	//TODO: Insert codes here
    float xMinus = (pos.x == bbMin.x) ? bbMin.x : pos.x - voxelWidth;
    float yMinus = (pos.y == bbMin.y) ? bbMin.y : pos.y - voxelWidth;
    float zMinus = (pos.z == bbMin.z) ? bbMin.z : pos.z - voxelWidth;
    vec3 posXminus = vec3(xMinus, pos.y, pos.z);
    vec3 posYminus = vec3(pos.x, yMinus, pos.z);
    vec3 posZminus = vec3(pos.x, pos.y, zMinus);
    float gradientX = sampleVolume(pos) - sampleVolume(posXminus);
    float gradientY = sampleVolume(pos) - sampleVolume(posYminus);
    float gradientZ = sampleVolume(pos) - sampleVolume(posZminus);
    result = normalize(vec3(gradientX, gradientY, gradientZ));
    return result;
}

/**
 *	Computes the color of the lit surface of an object, using a global
 *	directional light source.
 *
 *	@param objColor The diffuse color of the object.
 *	@param normal The surface normal at the position that should be lit.
 *	@param eyeDir The direction from the surface to the camera position.
 *	@return The color of the lit surface
 */
vec4 lighting(vec4 objColor, vec3 normal, vec3 eyeDir)
{
    // TODO Insert code here
    vec4 color = objColor;
    vec3 halfwayDir = normalize(-lightDir + eyeDir);
    float spec = pow(max(dot(normal, halfwayDir), 0.0), exponent);
    float diff = max(dot(normal, -lightDir), 0.0);
    vec4 specColor = ks * lightColor * spec;
    vec4 diffColor = kd * objColor * diff;
    vec4 ambiColor = ka * objColor;
    color = ambiColor + diffColor +  specColor;
    return color;
}

/**
 *	Correct opacity for the current sampling rate
 *
 *	@param alpha: input opacity.
 *	@param samplingRatio: the ratio between current sampling rate and the original.
 */
float opacityCorrection(in float alpha, in float samplingRatio)
{
    float a_corrected = 1.0 - pow(1.0 - alpha, samplingRatio);
    return a_corrected;
}

/**
 *	Main Function: 
 *  Computes the color for the given fragment.
 *
 *	@param fragColor OUT: The color of the pixel / fragment.
 *	@param fragCoord The coordinate of the fragment in screen space
 */
void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
	vec2 uv = fragCoord.xy / iResolution.xy;
    float aspect = iResolution.x / iResolution.y;
    
    /******************** compute camera parameters ********************/
    
    // camera movement  
    float camSpeed = 0.5;
    vec3 camPos = 7.0 * vec3(cos(iTime*camSpeed), 0.5, sin(iTime*camSpeed));
    vec3 camDir = -normalize(camPos);
    vec3 camUp = vec3(0.0, 1.0, 0.0);
    vec3 camRight = normalize(cross(camDir, camUp));
    camUp = normalize(cross(camRight, camDir));
    
    /************ compute ray direction (OpenGL style) *****************/
    vec2 myUV = 2.0 * uv - 1.0;
    float fovx = 2.0 * atan(tan(fovy / 2.0) * aspect);
    
    vec3 uL = (tan(fovx*0.5)*zNear) * (-camRight) + (tan(fovy*0.5) * zNear) * camUp + camDir * zNear + camPos;
    vec3 lL = (tan(fovx*0.5)*zNear) * (-camRight) + (tan(fovy*0.5) * zNear) * (-camUp) + camDir * zNear + camPos;
    vec3 uR = (tan(fovx*0.5)*zNear) * camRight + (tan(fovy*0.5) * zNear) * camUp + camDir * zNear + camPos;
    vec3 lR = (tan(fovx*0.5)*zNear) * camRight + (tan(fovy*0.5) * zNear) * (-camUp) + camDir * zNear + camPos;
    
    vec3 targetL = mix(lL, uL, uv.y);
    vec3 targetR = mix(lR, uR, uv.y);
    vec3 target = mix(targetL, targetR, uv.x);
    
    vec3 rayDir = normalize(target - camPos);
        
    /******************* test against bounding box ********************/
    float tNear, tFar;
    bool hit = intersectBoundingBox(camPos, rayDir, tNear, tFar);
    vec4 background = vec4(1.0);
    if(tNear < 0.0)
        tNear = 0.0;
    
    if(!hit)
    {
        fragColor = background;
        return;
    }
    
    
    float t = tNear;
    vec3 pos = camPos;
    float tstep = (bbMax.z - bbMin.z) / float(sampleNum);
    vec4 finalColor = vec4(0);
    vec3 finalGradient = vec3(0);
    // ratio between current sampling rate vs. the original sampling rate
    float sampleRatio = 1.0 / (float(sampleNum) * voxelWidth);
    
    /******************** main raycasting loop *******************/
    while(finalColor.a < 0.99 && t < tFar){
        pos = camPos + t * rayDir;
        float sampleValue = sampleVolume(pos);
        vec4 color = transferFunction(sampleValue);

        
        #ifdef USE_INTERMEDIATE
        vec3 grad = gradientIntermediate(pos);
        #else
        #ifdef USE_CENTRAL
        vec3 grad = gradientCentral(pos);
        #else
        vec3 grad = vec3(0);
        #endif // USE_CENTRAL
        #endif // USE_INTERMEDIATE
        
    
   	 /****************** lighting ********************************/  
        {
           finalGradient = grad;
        }
        color = lighting(color, finalGradient, -rayDir);
        // blending with pre-multiplied color!
        color.a = opacityCorrection(color.a, sampleRatio);
        color.rgb *= color.a;
        finalColor += color * (1.0 - finalColor.w);
        t += tstep;
    }
    fragColor = finalColor * finalColor.a + (1.0 - finalColor.a) * background;
}